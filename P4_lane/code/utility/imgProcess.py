# Use color transforms, gradients, etc., to create a thresholded binary image.
import numpy as np
import cv2
import matplotlib.pyplot as plt


class Image_Process:

    def sobel_thresh(self):
        '''
        Convert image to gray scale and threshold on edge intensity obtained by sobel filter
        '''
        if (self.sobel_flag == True):
            self.gray = cv2.cvtColor(self.img, cv2.COLOR_RGB2GRAY)
            # Sobel x
            sobelx = cv2.Sobel(self.gray, cv2.CV_64F, 1, 0)  # Take the derivative in x
            # magnitude of sobel filter result
            abs_sobelx = np.absolute(sobelx)
            # scale to 0 to 255
            scaled_sobel = np.uint8(255 * abs_sobelx / np.max(abs_sobelx))
            # Threshold x gradient
            thresh_min = 20
            thresh_max = 255
            # sxbinary is the binary image generated by sobel filter
            self.sxbinary[(scaled_sobel >= thresh_min) & (scaled_sobel <= thresh_max)] = 1

    def hls_thresh(self):
        '''
        Threshold on saturation and lightness channel
        '''
        # Convert to HLS color space and separate the S channel
        # Note: img is the undistorted image
        hls = cv2.cvtColor(self.img, cv2.COLOR_RGB2HLS)
        l_channel = hls[:, :, 1]
        s_channel = hls[:, :, 2]

        # Threshold values for saturation channel
        s_thresh_min = 170
        s_thresh_max = 255

        # Threshold values for lightness channel
        l_thresh_min = 40
        l_thresh_max = 255

        if self.hls_saturation_flag == True:
            self.s_binary[(s_channel >= s_thresh_min) & (s_channel <= s_thresh_max)] = 1

        if self.hls_lightness_flag == True:
            self.l_binary[(l_channel >= l_thresh_min) & (l_channel <= l_thresh_max)] = 1

    def stack_channel(self, sobel_flag, hls_saturation_flag, hls_lightness_flag):
        '''
        :param sobel_flag: perform gradient thresholding
        :param hls_saturation_flag: pefform thresholding on saturation channel
        :param hls_lightness_flag:  perform thresholding on lightness channel
        '''
        self.sobel_flag = sobel_flag
        self.hls_saturation_flag = hls_saturation_flag
        self.hls_lightness_flag = hls_lightness_flag

        # create blank images (w x h x channel=1) to hold filtered result for
        # sobel x, saturation, and lightness
        self.img_h, self.img_w, _ = self.img.shape

        self.sxbinary = np.zeros((self.img_h, self.img_w))
        self.s_binary = np.zeros((self.img_h, self.img_w))
        self.l_binary = np.zeros((self.img_h, self.img_w))

        # threshold on sobel and hls
        self.sobel_thresh()
        self.hls_thresh()
        # Stack each channel to view their individual contributions
        # This returns a stack of the three binary images, whose components you can see as different colors
        self.color_binary = np.dstack((self.l_binary, self.sxbinary, self.s_binary)) * 255
        self.color_binary= self.color_binary.astype(np.uint8)


    def combine_thresh(self):
        # Combine the all the binary thresholds
        self.combined_binary = np.zeros_like(self.sxbinary)
        self.combined_binary[(self.s_binary == 1) & (self.l_binary == 1) | (self.sxbinary == 1)] = 1

        # dilation followed by erosion. It is useful in closing small holes inside the foreground objects
        kernel = np.ones((5, 5), np.uint8)
        closing = cv2.morphologyEx(self.combined_binary.astype(np.uint8), cv2.MORPH_CLOSE, kernel)

        return closing

    def visualize(self, img, outdir=None):
        self.img = img
        # Plotting thresholded images
        f, ax = plt.subplots(2, 3, figsize=(20, 10))
        plt.tight_layout()

        self.stack_channel(sobel_flag=True, hls_saturation_flag=False, hls_lightness_flag=False)
        ax[0][0].set_title('sobel thresholds')
        ax[0][0].imshow(self.color_binary)
        self.stack_channel(sobel_flag=False, hls_saturation_flag=True, hls_lightness_flag=False)
        ax[0][1].set_title('hls saturation channel thresholds')
        ax[0][1].imshow(self.color_binary)
        self.stack_channel(sobel_flag=False, hls_saturation_flag=False, hls_lightness_flag=True)
        ax[0][2].set_title('hls lightness channel thresholds')
        ax[0][2].imshow(self.color_binary)
        self.stack_channel(sobel_flag=True, hls_saturation_flag=True, hls_lightness_flag=True)
        ax[1][0].set_title('stacked channels')  # remove effects from shadow
        ax[1][0].imshow(self.color_binary, cmap='gray')

        closing = self.combine_thresh()
        ax[1][1].set_title('combined binary')  # remove effects from shadow
        ax[1][1].imshow(self.combined_binary)
        ax[1][2].set_title('after closing')  # remove effects from shadow
        closing *= 255
        ax[1][2].imshow(closing, cmap='gray')

        if (outdir is not None):
            plt.savefig(outdir + "first_frame_channels.jpg")
        plt.close()

        return closing

